HashMap Question:- using Brute Force
Q1:- We are given an array of numbers. We have to find print any number with maximum frequency and minimum frequency

Example TestCase:-  Arr=[3,2,3,2,4,3]
           Frequencies of elements of array are:-
                          3 - 3
                          2 - 2
                          4 - 1
           maximum Frequency:- Element is 3, Frequency is 3
           Minumum Frequency;- Element is 4, Frequency is 1
-> Brute Force Approach will work in O(N^2) because of 2 nested for loops 

Optimized Approach:- use HashMap to store the frequencies of elements where key will be the array element and value will be the frequency of array element and update our maximum frequency and minimum frequency


Code:- 
import java.util.HashMap;
import java.util.Map;
 
public class Main {
    public static void main(String[] args) {
        int n = 6;
        int[] arr = {1, 1, 2, 3, 3, 3};
 
        Map<Integer, Integer> mp = new HashMap<>();
        int maxiFreq = Integer.MIN_VALUE, maxiElement = arr[0];
        int miniFreq = Integer.MAX_VALUE, miniElement = arr[0];
 
        for (int i = 0; i < arr.length; i++) {
            mp.put(arr[i], mp.getOrDefault(arr[i], 0) + 1);
        }
 
        for (Map.Entry<Integer, Integer> num : mp.entrySet()){
            if (num.getValue() >= maxiFreq){
                maxiFreq = num.getValue();
                maxiElement = num.getKey();
            }
            if (num.getValue() <= miniFreq){
                miniFreq = num.getValue();
                miniElement = num.getKey();
            }
        }
 
 
 
        System.out.println("Max frequency element: " + maxiElement + " with frequency: " + maxiFreq);
        System.out.println("Min frequency element: " + miniElement + " with frequency: " + miniFreq);
    }
}




Q2:- Check if there are any two Equal numbers in an array at a distance less than or equal to k
Sol:-
           Brute Force :- Just Use 2 For loops and check if distance between any 2 Equal elements is less than or equal to k, print(yes), otherwise, we will print (no)
import java.util.*;

Code:- 

public class Main {
    public static boolean containsNearbyDuplicateBruteForce(int[] nums, int k) {
        int n = nums.length;
        for (int i = 0; i < n; ++i) {
            for (int j = i + 1; j < n && j <= i + k; ++j) {
                if (nums[i] == nums[j]) {
                    return true;
                }
            }
        }
        return false;
    }
 
    public static void main(String[] args) {
        int[] nums = {1, 1, 3, 1, 2, 3};
        int k = 2;
        if (containsNearbyDuplicateBruteForce(nums, k)) {
            System.out.println("There are two equal numbers within distance " + k);
        } else {
            System.out.println("No two equal numbers found within distance " + k);
        }
    }
}



Optimised using Hashmaps:- 

For every element, we need to check only the last Occurence or the Last index where this element has occurred before. We can use a hashmap which will tell us the Last occurrence where this element has occurred. 

We just need to calculate the distance between current Occurence and Last Occurence of Current Element.

If this Distance <= k, we have found a valid pair. We will return true. Otherwise, We will return false because we are now sure that we have not found any valid pair of equal elements whose distance btw them is <= k.

Code:-

import java.util.*;
 
public class Main {
    public static boolean containsNearbyDuplicateOptimized(int[] nums, int k) {
        Map<Integer, Integer> numIndices = new HashMap<>();
        for (int i = 0; i < nums.length; ++i) {
            if (numIndices.containsKey(nums[i]) && i - numIndices.get(nums[i]) <= k) {
                return true;
            }
            numIndices.put(nums[i], i);
        }
        return false;
    }
 
    public static void main(String[] args) {
        int[] nums = {1, 1, 3, 1, 2, 3};
        int k = 2;
        if (containsNearbyDuplicateOptimized(nums, k)) {
            System.out.println("There are two equal numbers within distance " + k);
        } else {
            System.out.println("No two equal numbers found within distance " + k);
        }
    }
}




Q3:- Count all the (i,j) Pairs such that b[i] + b[j] == k (count of such pairs.) [i<j] 

Sol:-  
           Brute Force Approach:- Iterate over all i and j and check if(arr[i] + arr[j] == k), increment cnt by 1. At the end, print this total Count

Code:- For Brute Force
import java.util.*;
public class Main {
    public static int bruteForceCountPairs(int[] arr, int k) {
        int count = 0;
        for (int i = 0; i < arr.length - 1; ++i) {
            for (int j = i + 1; j < arr.length; ++j) {
                if (arr[i] + arr[j] == k) {
                    count++;
                }
            }
        }
        return count;
    }
 
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5};
        int k = 6;
        System.out.println("Count of pairs: " + bruteForceCountPairs(arr, k));
    }
}



Optimised Approach:- At each Index i, we will find the Complementary Element We need. Now, we will check if this Complementary Element is present in Map Already, we will do cnt+=frequency of complement. We will now update entry of our current index element in map.

Code:- For Hash Map 
import java.util.*;
 
public class Main {
    static int countPairsWithSum(int[] b, int k) {
        int count = 0;
        Map<Integer, Integer> seen = new HashMap<>();
 
        for (int j = 0; j < b.length; ++j) {
            int complement = k - b[j];
            if (seen.containsKey(complement)) {
                count++;
            }
            seen.put(b[j], j);
        }
 
        return count;
    }
 
    public static void main(String[] args) {
        int[] b = {1, 2, 3, 4, 5};
        int k = 6;
        int count = countPairsWithSum(b, k);
 
        System.out.println("Count of pairs with sum " + k + " is: " + count);
    }
}
